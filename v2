-- Egg Finder and Hatcher (Delta compatible with egg priority, egg_amount, and open_eggs options)

local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local PlaceId = game.PlaceId

-- Configuration Variables
local egg_amount = "max" -- Number of eggs to hatch at once (set to "max" for max eggs)
local egg_priority = "aura-egg" -- Priority egg (e.g., "aura-egg", "event-1", etc.)
local open_eggs = true -- Set to true to hatch eggs, false to just find them
local target_eggs = {"aura-egg", "event-1", "event-2", "rainbow-egg", "nightmare-egg", "void-egg", "event-3"}

-- Initialize egg selection
local selectedEgg = "aura-egg"  -- Default to "aura-egg" if no selection made yet

-- GUI Setup
local gui = Instance.new("ScreenGui", game.CoreGui)
gui.Name = "EggFinderUI"

local frame = Instance.new("Frame", gui)
frame.Size = UDim2.new(0, 200, 0, 100)
frame.Position = UDim2.new(0, 10, 0, 100)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)

local label = Instance.new("TextLabel", frame)
label.Size = UDim2.new(1, 0, 0, 30)
label.Text = "Select Egg:"
label.TextColor3 = Color3.new(1, 1, 1)
label.BackgroundTransparency = 1

for i, eggName in ipairs(target_eggs) do
    local btn = Instance.new("TextButton", frame)
    btn.Size = UDim2.new(1, 0, 0, 20)
    btn.Position = UDim2.new(0, 0, 0, 30 + (i - 1) * 20)
    btn.Text = eggName
    btn.TextColor3 = Color3.new(1, 1, 1)
    btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)

    btn.MouseButton1Click:Connect(function()
        selectedEgg = eggName
        label.Text = "Selected: " .. eggName
    end)
end

-- Server hop function
local checked = {}
function hop()
    local cursor = ""
    while true do
        local url = ("https://games.roblox.com/v1/games/%s/servers/Public?limit=100&cursor=%s&sortOrder=Asc"):format(PlaceId, cursor)
        local data = HttpService:JSONDecode(game:HttpGet(url))
        for _, s in ipairs(data.data) do
            if not checked[s.id] and s.playing < s.maxPlayers and s.id ~= game.JobId then
                checked[s.id] = true
                TeleportService:TeleportToPlaceInstance(PlaceId, s.id, LocalPlayer)
                return
            end
        end
        if not data.nextPageCursor then break end
        cursor = data.nextPageCursor
    end
end

-- Function to hatch the egg (if open_eggs is true)
function openEgg(egg)
    if open_eggs then
        print("Opening egg:", egg.Name)
        -- Implement egg opening logic (e.g., fire a RemoteEvent or interact with the egg)
    else
        print("Egg found but not opening:", egg.Name)
    end
end

-- Main loop (find egg, teleport, server hop, hatch eggs)
spawn(function()
    while true do
        -- Prioritize the selected egg
        local eggToOpen = nil
        local foundEggs = {}

        for _, eggName in ipairs(target_eggs) do
            local egg = workspace:FindFirstChild(eggName)
            if egg then
                table.insert(foundEggs, egg)
            end
        end

        -- Sort found eggs by priority
        table.sort(foundEggs, function(a, b)
            if a.Name == egg_priority then return true end
            if b.Name == egg_priority then return false end
            return false -- No priority sorting for other eggs
        end)

        -- Select eggs to open based on egg_amount
        local eggCount = 0
        for _, egg in ipairs(foundEggs) do
            if eggCount < (egg_amount == "max" and #foundEggs or egg_amount) then
                openEgg(egg)
                eggCount = eggCount + 1
            else
                break
            end
        end

        -- If no eggs were found, hop servers
        if #foundEggs == 0 then
            hop()
        end

        task.wait(0.5) -- Minimal delay for checking eggs
    end
end)
